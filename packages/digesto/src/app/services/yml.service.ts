import { buildTableSchema } from "../utils/zod-schema-builder.js";
import type { YmlRepository } from "../repositories/yml.repository.js";
import { YmlSchema, ymlSchema } from "../schemas/yml.schema.js";
import * as bcrypt from "bcrypt";

type TableSchemas = Record<string, ReturnType<typeof buildTableSchema>>;

export class YmlService {
  private readonly fileLocation = `${process.cwd()}/backend/api.yml`;
  private readonly ymlRepository: YmlRepository;
  private parsedYmlContent: YmlSchema | null = null;
  private tableSchemas: TableSchemas | null = null;

  constructor(ymlRepository: YmlRepository) {
    this.ymlRepository = ymlRepository;
  }

  load({ force } = { force: true }) {
    if (!force && !!this.parsedYmlContent) {
      return this.parsedYmlContent;
    }

    const ymlContent = this.ymlRepository.readFile(this.fileLocation);
    const parsedYmlContent = ymlSchema.parse(ymlContent);
    this.parsedYmlContent = parsedYmlContent;

    this.loadTablesSchemaValidation();

    return parsedYmlContent;
  }

  private loadTablesSchemaValidation() {
    if (!this.parsedYmlContent) {
      return;
    }

    const tableSchemas: TableSchemas = {};

    for (const tableDef of Object.values(this.parsedYmlContent.tables)) {
      tableSchemas[tableDef.tableName] = buildTableSchema(tableDef);
    }

    this.tableSchemas = tableSchemas;
  }

  private getTableSchemaByTableName(tableName: string) {
    if (!this.parsedYmlContent) {
      return;
    }

    const tableSchema = Object.values(this.parsedYmlContent.tables).find(
      (item) => item.tableName === tableName
    );

    return tableSchema;
  }

  public validateTableSchema(
    tableName: string,
    data: Record<string, unknown>,
    options?: {
      omitFields: Omit<string, any>;
    }
  ) {
    this.load();

    if (!this.tableSchemas || !this.parsedYmlContent) {
      return;
    }

    let zodSchema = this.tableSchemas[tableName];

    if (!zodSchema) {
      return;
    }

    const tableSchema = this.getTableSchemaByTableName(tableName);

    let omitFields = options?.omitFields ?? {};

    if (tableSchema) {
      // Omit auto-generated fields
      const omitAutoGeneratedFields = Object.entries(
        tableSchema.columns
      ).reduce((acc, curr) => {
        const [columnName, columnOptions] = curr;

        if (columnOptions.generated) {
          return {
            ...acc,
            [columnName]: true,
          };
        }

        return acc;
      }, {});

      omitFields = {
        ...omitAutoGeneratedFields,
        ...omitFields,
      };
    }

    if (Object.keys(omitFields ?? {}).length > 0) {
      zodSchema = zodSchema.omit(omitFields);
    }

    zodSchema.parse(data);
  }

  public validateAndHashSensitiveColumns(
    tableName: string,
    data: Record<string, unknown>
  ) {
    this.load();

    if (!this.tableSchemas || !this.parsedYmlContent) {
      return;
    }

    const tableSchema = this.getTableSchemaByTableName(tableName);

    if (!tableSchema) {
      return;
    }

    const sensitiveFields = Object.entries(tableSchema.columns).filter(
      ([, item]) => item.type === "password"
    );

    if (sensitiveFields.length === 0) {
      return;
    }

    const saltRounds = 10;

    for (let [fieldName] of sensitiveFields) {
      const salt = bcrypt.genSaltSync(saltRounds);
      const hash = bcrypt.hashSync(data[fieldName] as string, salt);
      data[fieldName] = hash;
    }
  }
}
